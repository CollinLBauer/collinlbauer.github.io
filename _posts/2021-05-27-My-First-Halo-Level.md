---
layout: post
title: "Modding Halo: My First Level"
date: 2021-05-27
category: "portfolio"
prev_url: "/portfolio/2021/04/19/The-Halo-Game-Engine.html"
prev_title: "The Halo Game Engine"
---


When Gearbox released Halo Custom Edition and the Halo Editing Kit, they actually included a very handy tutorial, which can be found online [here](http://hce.halomaps.org/hek/index.html?start=references/level_design/mp_level_design/mp_ld_level_compilation.html). It includes lots of information on how the game engine works, how to use the various tools, and what is required to create a level in Halo. It was very much ahead of its time.

Today, many more guides can be found online, as the community has had two decades to mature. In particular, a community known as the *c20 Reclaimers* has a vast knowledge base located at [https://c20.reclaimers.net/], as well as an active Discord server. They have helped me a number of times already with questions I have had along the way.

Additionally, one user from this community, *General 101*, has created a few guides of his own. One of them is an adaptation of the original HEK tutorial, but made for Blender instead of 3DS Max. This guide can be found [here](https://general-101.github.io/HEK-Docs/w/Halo%201/H1%20Model%20Guides/JMS/Export/My%20First%20H1%20Level/My_First_H1_Level.html). Since I am using Blender, this guide will be incredibly helpful. Some of the tools I am using for this are of his design, which I am incredibly grateful for.


<br/>

## Creating the Test Map

*Technically, the title of this blog post is a lie. I actually have created a map for Custom Edition when I was much younger. It was bad. Really bad. So, while I have had prior exposure to the tools being used here, I am practically starting from square one. I have much more experience to draw from these days, anyway.*

To be clear, my goal with this initial map is not to create a finished product. Instead, I want to learn how to use these tools *properly*, and get a better understanding of the game engine as a whole, so that when I do create something more serious, I can use the knowledge gained from this experience to drive better design decisions. Besides, it's good modelling practice.

Because I already have a decent understanding of the game engine, I know there are a number of quirks I should probably iron out early on. The *tool* program used to compile the world geometry is particularly picky. Here are some quirks I have noticed so far.

1. Halo requires a "closed world" geometry base, meaning the basic geometry of the map needs to be a single, enclosed, completely sealed mesh. There cannot be any holes. All normals must be facing inward. Even outdoor levels have the sky completely boxed in, which is very different from how modern engines typically do things. I believe this requirement is to help the engine define "in bounds" versus "out of bounds", which helps optimize things like rendering and physics calculations. If something is out of bounds, those calculations need not be applied. Arguably, however, nothing should ever be out of bonds, but that's another topic.

2. When compiling world geometry, a number of bugs and issues can occur, such as planes intersecting in strange ways, surfaces not obeying physics properly, or duplicate or degenerate triangles and edges breaking the closed world rule. According to *tool*, a degenerate triangle is created whenever two or more edges exist in the same space. This can easily happen accidentally when modelling a mesh, and can be pretty tricky to identify and fix. Luckily, when *tool* notices something wrong, it generates a *.wrl* file which can be imported back into Blender to reveal where the bad geometry in question is.

3. The lighting engine in Halo works in strange ways, being generated by a script in *tool* and applied automatically to the *.scenario* file when completed. However, lighting will often generate in strange and unexpected ways, and will require some finagling to make it behave as desired. I will talk about this in greater detail later in the blog post.



### Geometry

Since this level is merely for testing, the geometry is fairly simple - just a big box with some structures placed about to test different properties. As I was working on it, I decided to add a few features for the following reasons:
- an open ceiling for a skybox and lighting
- an outer wall with light strips across the bottom, again, for lighting
- a high poly, grassy corner to test rendering limits and collision
- a round structure with to test lighting on curves
- some simple, arbitrary structures in another corner to cast shadows and give interesting collision
- various interiors to test rendering and culling
- a more detailed building with some elements that may be found in an actual map, like ramps, a ladder and transparent floor grates
- some free-floating objects that are unique meshes, instead of part of the intended geometry

While this level won't win any design awards, it should give me a pretty good idea of what the engine can and cannot do. I went through a few iterations while working on this, but the final result can be seen below.

![](https://raw.githubusercontent.com/CollinLBauer/collinlbauer.github.io/master/images/halo/dev_geo.png)
*level geometry*

Yes, it is ugly, but functional. I also tried to make everything relatively big, so I had plenty of room to play around when in-engine. Here's a picture with Master Chief in it for reference.

![](https://raw.githubusercontent.com/CollinLBauer/collinlbauer.github.io/master/images/halo/dev_scale.png)

As I practice more with blender, I will undoubtedly make better looking geometry than this. Heck, I already have, and I will show off more in future blog posts. But for now, let's move on to texturing this map.

### Texturing

One of the nice features of the Halo Editing Kit is that it comes with a number of textures out of the box from existing Halo levels, and even more can be extracted with 3rd party tools. I am no artist, so I will be using these for the level.

Texturing any 3D geometry requires going through a process called [*UV mapping*](https://en.wikipedia.org/wiki/UV_mapping), where a 2D image is mapped to the various surfaces of the 3D geometry. This can be a very complicated process, but thankfully, most of my geometry is fairly rectangular and simply repeats textures like grass and metal panels.

![](https://raw.githubusercontent.com/CollinLBauer/collinlbauer.github.io/master/images/halo/dev_uv_grass.png)
*this geometry repeats the grass texture hundreds of times*

Blender has a handy feature that makes unwrapping UVs for use cases like this fairly simple, called "cube projection", which treats most of the geometry as if it was part of a six-sided cube. Most of my geometry is rectangular, so this works for most of my map. I still had to adjust parts by hand while editing geometry, but it got simple as time went on.

![](https://raw.githubusercontent.com/CollinLBauer/collinlbauer.github.io/master/images/halo/dev_geo_textured.png)
*level geometry with textures*

There are other factors consider with textures, like diffuse and bump mapping, but those are topics for another day. (This rabbit hole is deep enough already.)

### Materials and Shaders

Halo uses an interesting materials system for identifying which surfaces have which properties. Blender has a very robust materials system itself, but when exporting the level, the only thing Halo cares about is the name.
- Some names are reserved for specific uses, like +sky, which is an invisible wall typically used for the ceilings of outdoor areas, and +portal, which is used for rendering calculations.
- Some symbols give materials special properties, like (%), which tells the engine that a texture has transparent parts, or (!), which states the material is render-only (has no collision).

For a quick example, consider a ladder. The first Halo game has several ladders in multiplayer maps, but these ladders are just a flat surface with special material definitions. I added one to my map and gave the material the name "ladder%^", which gives the texture transparency (%) and lets players climb it (^).

![](https://raw.githubusercontent.com/CollinLBauer/collinlbauer.github.io/master/images/halo/dev_ladder.png)

After material properties comes shader properties. As stated in the last blog post, Halo's game engine relies on "tags" to define almost every element of the game. One of the types of tags, known as shader tags, are used to apply different textures, lighting and physics properties to surfaces. Shader tags are not defined until importing the geometry, but we still need to know what goes where. Most of the time, we will use the *.shader_environment* tag type, but others exist. A relatively complete list of materials, shaders, and their properties can be found [here](http://hce.halomaps.org/hek/index.html?start=references/general/materials_overview.html).


<br/>

## Importing to the Game Engine

Now that the geometry is finalized in Blender, it's time to export it to the Halo game engine. Halo has a few proprietary file types we can export to. In this case, we need to export to *.jms*, or "Joint Model Skeleton". To achieve this, I am using the Blender plugin authored by General 101, as previously mentioned.

The process of getting a level from the modelling software to the engine looks something like this:
1. Export the .jms file.
2. Use *tool's* `structure` command to generate the scenario. Define shader tags when prompted.
3. Open the scenario in *Guerilla* and add desired tags, like skybox, weapons, vehicles, etc. If any shaders give off light, define them now.
4. Use *tool's* `lightmaps` command to illuminate the scenario. *The map will not be visible in Sapien until this is done.*
5. Open the scenario in *Sapien* to place world elements like spawn points, weapons, vehicles, and scenery.
6. Use *tool's* `build-cache-file` command to bundle the scenario into a playable map.
7. Launch Halo Custom Edition and load the map.

Creating a map requires plenty of iteration, so steps will be repeated from time to time in order to make certain changes and additions.

### The .scenario tag

An astute reader may notice that I use the terms "level," "map," and "scenario" somewhat interchangeably. In most video games, an instance of a game world is called a *level*, or sometimes a *world*, with a set beginning and end, like in Super Mario Bros. or Sonic. Colloquially, the term "scenario" usually refers to an instance of the game world, an that scenario is either called a "level" if it is made for singleplayer, or a "map" if it is designed for multiplayer, though this is a minor distinction. Many other games follow a similar pattern, though with some variation. Blizzard's StarCraft series, for example, calls singleplayer scenarios missions, while multiplayer levels are still called maps. On the backend, however, both singleplayer and multiplayer scenarios use the same file format.

For Halo's backend, there are two important file formats for us to know: *.map* and *.scenario*. A *.scenario* file contains references to a series of "tags" that comprise all of a single level's data, including 3D geometry, collision, textures, player and AI spawns, weapons, vehicles, and so on. This *.scenario* file can be edited with Sapien and Guerilla, but in order to test and play it in game, must be built with *tool* into a *.map* file. This final *.map* is what is read by the game engine for singleplayer and multiplayer. Both singleplayer "levels" and multiplayer "maps" use this file format, with the only true distinction between the two being a flag set in the *.scenario* tag.

### Adding tags with Guerilla

There are a few things that need to be taken care of before populating the map. Light sources are needed, but since this level is outdoors, the majority of this can be handled by a .sky tag, which includes light natively. For this, I simply stole the sky from the map Timberland. Later on, I also added some light sources as materials, so their shaders had to be manually edited as well.

Several other things can be added at this time, like vehicles, weapons, and scenery. I skipped scenery for now, but added the default Halo sandbox equipment so I could use them for testing in the level.

### Getting to the fun part

Now that we have the necessary tags, we can finally open the scenario in Sapien and start working on...

![](https://raw.githubusercontent.com/CollinLBauer/collinlbauer.github.io/master/images/halo/dev_scale_whoops.png)

...Oh, it's, uh, a little small.

![](https://raw.githubusercontent.com/CollinLBauer/collinlbauer.github.io/master/images/halo/dev_scale_fixed.png)

That's better.

Like I said, map creation is an iterative process, and going back to make changes and fixes is quite common. With that fixed, I was able to add things like initial spawn points, weapons, vehicles (pictured above), and even objectives to test Capture the Flag with a friend.

<br/>

While iterating on this map, I hit a number of roadblocks and complications, especially with the lighting engine. I had to research a lot of different things to get a better understanding of how it works. Not everything I ran into is pictured, but I detailed the crux of my research below.

<br/>

## Halo's primitive lighting engine

Halo uses a [rasterizer](https://en.wikipedia.org/wiki/Rasterisation)-based rendering engine. In order to draw a single frame of a scene, for each plane in the world geometry, it applies a given texture to that plane, transforms it according to 3D position data, then draws it to the screen based off of the angle and position of the player viewport. It is a very effective way of rendering 3D geometry, but it comes with some drawbacks. Rasterization alone has no concept of light since it is just the transformation of flat 2D images. To fix this, a number of tricks can be applied to approximate lighting effects, such as shadow mapping or ambient occlusion.

In Halo's case, the primary way it simulates light is by creating and applying something called a **lightmap**, first applied by the 1996 game [Quake](https://www.bluesnews.com/abrash/chap68.shtml). In short, a lightmap is a complex texture generated algorithmically and applied on top of the world's base textures, to simulate granular levels of illumination. Different games handle this in different ways, with some preferring to bake them into the base textures, and others applying on top of them. Halo does the latter of the two.

![](https://raw.githubusercontent.com/CollinLBauer/collinlbauer.github.io/master/images/halo/bloodgulch_lm0.png)
*Part of the lightmap from Blood Gulch*

### Light sources

Halo's method of generating lightmaps relies on a few different effects. Most of the time, the primary source of light is the "sky" tag, which stores some parameters like the relative position of the sun/moon and its brightness. (The sky stores more information than that, but this is all we care about right now.) Beyond that, different materials can be flagged as light emitting, with a brightness and a color. The lighting engine will use both types of light source to calculate the resulting lightmaps.

### Generating the lightmap

Remember how I said Halo stores almost all of a level's data in different tags? The lightmap is one such tag, but it is rather unique in how it is created. Rather than being completely user-defined, it is instead algorithmically generated by *tool's* radiosity command (usually, anyway). *Tool* takes the geometry data, then looks at the properties of the light sources and skybox, where applicable, and runs the level through an algorithm that generates a lightmap image.

Radiosity is an earlier method of diffusing light in an iterative process, giving the resulting lightmap a more realistic feel, instead of having hard shadows. It also helps to better light corners not in the direct path of light sources. This process takes time, so *tool* will let programmers define lower levels of detail, mostly for debugging.

![](https://raw.githubusercontent.com/CollinLBauer/collinlbauer.github.io/master/images/halo/dev_radiosity.png)
*the level during the radiosity process*

Generating a good lightmap took several attempts, and as you will see later, is still not perfect. A lot of problems come from how the engine tries to smooth surfaces together, causing bleed effects, among other things.

### Smoothing

*Tool* uses a few tricks to try and make lighting look more realistic. One of them is light smoothing. In short, when two faces are "smoothed" together, *tool* will try to let light curve around these edges, giving a more rounded appearance. If they are not smoothed, and the edge between them is "sharp", it will instead calculate light for each face individually.

In the below pictures I have the round structure I made to test how lighting behaves under different circumstances. Notably it has a rounded top, with several light sources sticking out the top. Behind the structure are several other light sources as well. In the first picture, I exported the geometry as-is with no groups defined (basically treating the entire level as "smooth"). In the second, I added 

![](https://raw.githubusercontent.com/CollinLBauer/collinlbauer.github.io/master/images/halo/dev_smoothing_broken.png)  
*without smoothing*


![](https://raw.githubusercontent.com/CollinLBauer/collinlbauer.github.io/master/images/halo/dev_smoothing_manual.png)  
*with smoothing*

As you can see, defining smoothing groups goes a long way towards making lighting behave more predictably. The first one clearly has a lot of issues, with the structure looking incredibly blotchy, and the background lights not working at all. The second picture, while not perfect, looks a lot better, with lights actually working and the dome of the building appearing much more evenly lit.

Technically speaking, "smoothing groups" is a feature of 3DS Max, not Blender. Instead, Blender lets users define an edge as a "sharp" edge, and from there an "edge split" modifier can be applied. The exporter plugin takes care of the rest.

<br/>

## The "Final" Product

The below clip is a quick walkaround the resulting level. Pretty much everything works as advertised, which is promising. This means creating a proper level will be a much smoother experience. I have my workflow.

<iframe width="560" height="315" src="https://www.youtube.com/embed/-Whdud-L9YA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

The level works great, but as you can probably tell, there are a number of problems that occur while walking around. Lighting seems odd in some places, and in others, level geometry pops in and out randomly. I expected this given the age of the engine, and have been looking into how to properly solve these issues. My next blog post will talk about these problems in more detail and show some solutions the community has created over the years.