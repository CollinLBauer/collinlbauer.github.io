---
layout: post
title: "Modding Halo: My First Level
date: 
category: "portfolio"
---


When Gearbox released Halo Custom Edition and the Halo Editing Kit, they actually included a very handy tutorial, which can be found online [here](http://hce.halomaps.org/hek/index.html?start=references/level_design/mp_level_design/mp_ld_level_compilation.html). It includes lots of information on how the game engine works, how to use the various tools, and what is required to create a level in Halo. It was very much ahead of its time.

Today, many more guides can be found online, as the community has had two decades to mature. In particular, a community known as the *c20 Reclaimers* has a vast knowledge base located at [https://c20.reclaimers.net/], as well as an active Discord server. They have helped me a number of times already with questions I have had along the way.

Addititonally, one user from that community, *General 101*, has created a few guides of his own. One of them is an adaptation of the original HEK tutorial, but made for Blender instead of 3DS Max. This guide can be found [here](https://general-101.github.io/HEK-Docs/w/Halo%201/H1%20Model%20Guides/JMS/Export/My%20First%20H1%20Level/My_First_H1_Level.html). Since I am using Blender, this guide will be incredibly helpful.


<br/>

## Creating the Test Map

*Technically, the title of this blog post is a lie. I actually have created a map for Custom Edition before, when I was much younger. It was bad. Really bad. So, while I have had prior exposure to the tools being used here, I am practically starting from square one. I have much more experience to draw from these days, anyway.*

To be clear, my goal with this initial map is not to create a finished product. Instead, I want to learn how to use these tools *properly*, and get a better understanding of the game engine as a whole, so that when I do create something more serious, I can use the knowledge gained from this experience to drive better design decisions. Besides, it's good modelling practice.

Because I already have a decent understanding of the game engine, I know there are a number of quirks I should probably iron out early on. First, the *tool* used to compile the world geometry is incredibly picky. Here are some important quirks to note.

1. Halo requires a "closed world" geometry base, meaning the basic geometry of the map needs to be a single, enclosed, completely sealed mesh. There cannot be any holes. All normals must be facing inward. Even outdoor levels have the sky completely boxed in, which is very different from how modern engines typically do things. I believe this requirement is to help the engine define "in bounds" versus "out of bounds", which helps optimize things like rendering and physics calculations. If something is out of bounds, those calculations need not be applied. Arguably, however, nothing should ever be out of bonds, but that's another topic.

2. When compiling world geometry, a number of bugs and issues can occur, such as planes intersecting in strange ways, surfaces not obeying physics properly, or duplicate or degenerate triangles and edges breaking the closed world rule. According to *tool*, a degenerate triangle is created whenever two or more edges exist in the same space. This can easily happen accidentally when modelling a mesh, and can be pretty tricky to identify and fix. Luckily, when *tool* notices something wrong, it generates a *.wrl* file which can be imported back into Blender to reveal where the bad geometry in question is.

3. The lighting engine in Halo works in strange ways, being generated by a script in *tool* and applied automatically to the *.scenario* file when completed. However, very often will generate in strange and unexpected ways, and will require some finagling to get it to behave as desired. I talk about this in greater detail later in the blog post.


### Geometry


### Materials and Shaders

Halo's game engine relies on "tags" to define almost every element of the game. I will talk about this in more detail later, but for now, what we need to know is how specific types of tags, known as "shader tags" are used to apply different textures, lighting and physics properties to surfaces. Most of the time, we will use the *.shader_environment* tag type, but others exist. A relatively complete list of tags and their properties can be found [here](http://hce.halomaps.org/hek/index.html?start=references/general/materials_overview.html).

We won't technically be defining these tags first

<br/>

## Importing to the Game Engine

An astute reader may notice that I use the terms "level," "map," and "scenario" somewhat interchaneably. In most video games, an instance of a game world is called a *level*, or sometimes a *world*, with a set beginning and end, like in Super Mario Bros. or Sonic. Colloquially, the term "scenario" usually refers to an instance of the game world, an that scenario is either called a "level" if it is made for singleplayer, or a "map" if it is designed for multiplayer, though this is ia minor distinction. Many other games follow a similar pattern, though with some variation. Blizzard's StarCraft series, for example, calls singleplayer scenarios missions, while multiplayer levels are sitll called maps. On the backend, however, both singleplayer and multiplayer scenarios use the same file format.

For Halo's backend, there are two important file formats for us to know: *.map* and *.scanrio*. A *.scenario* file contains references to a series of "tags" that comprise all of a single level's data, including 3D geometry, collision, textures, player and AI spawns, weapons, vehicles, and so on. This *.scenario* file can be editied with Sapiena and Guerilla, but in order to test and play it in game, must be built with *tool* into a *.map* file. This final *.map* is what is read by the game engine for singleplayer and multiplayer. Both singleplayer "levels" and multiplayer "maps" use this file format, with the only true distinciton between the two being a flag set in the *.scenario* tag.


### Exporting, Compiling, Lighting


### Adding tags with Guerilla


### Getting to the fun part



<br/>

## Halo's primitive lighting engine

Unsurprisingly, Halo uses a [rasterizer](https://en.wikipedia.org/wiki/Rasterisation)-based rendering engine. In order to draw a single frame of a scene, for each plane in the world geometry, it applies a given texture to that plane, transforms it according to 3D position data, then draws it to the screen based off of the angle and position of the player viewport. It is a very effective way of rendering 3D geometry, but it comes with some drawbacks. Rasterization alone has no concept of light, since it is just the transformation of flat 2D images. To fix this, a number of tricks can be applied to approximate lighting effects, such as shadow mapping or ambient occlusion.

In Halo's case, the primary way it simulates light is by creating and applying something called a **lightmap**, first applied by the 1996 game [Quake](https://www.bluesnews.com/abrash/chap68.shtml). In short, a lightmap is a complex texture generated algorithmically and applied on top of the world's base textures, to simulate granular levels of illumination. Different games handle this in different ways, with some preferring to bake them in to the base textures, and others applying on top of them. Halo does the latter of the two.

### Light sources

Halo's method of generating lightmaps relies on a few different effects. Most of the time, the primary source of light is the "sky" tag, which stores some parameters like the relative positiion of the sun/moon and its brightness. (The sky stores more information than that, this is all we care about right now.) Beyond that, parts of geometry can be flagged as light emitting, with a brightness and a color. The lighting engine uses both of those to calculate its lightmaps.

### Radiosity

Remember how I said Halo stores almost all of a level's data in different tags? The lightmap is one such tag. However, what makes it unique is that, rather than being completely user-defined, it is instead generated by *tool*


### Smoothing

Halo's *tool* uses a few tricks to try and make lighting look more realistics. One of them is light smoothing. In short, when two faces are "smoothed" together, *tool* will try to let light curve around these edges, giving a more rounded appearance. If they are not smoothed, and the edge between them "sharp", it will instead calculate light for each face individually.

In the below pictures I have a small structures I made to test how lighting behaves under different circumstances. Notably it has a rounded top, with several light sources sticking out the top. Behind the structure are several other light sources as well. In the first picture, I exported the geometry as-is with no groups defined (basically treating the entire level as "smooth"). In the second, I added 

![]()  
*without smoothing*


![]()  
*with smoothing*

As you can see, defining smoothing groups goes a long way towards making lights behave more realistically. The first one clearly has a lot of issues, with the structure looking incredibly blotchy, and the background lights not working at all. The second picture, while not perfect, looks a lot better, with lights actually working and the dome of the building appearing much more evenly lit.

Technically speaking, "smoothing groups" is a feature of 3DS Max, but not of Blender. Instead, Blender lets users define an edge as a "sharp" edge, and from there an "edge split" modifier can be applied. In practice, these two tools achieve the same result once the geometry is exported, but it definitely took some fiddling to figure out.

<br/>

## The Final-ish Product

